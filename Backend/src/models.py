"""
Request and response models used in the FastAPI routes (and in some of the implementations).
"""
import logging
import sys
from typing import List, Dict, Any, Optional, Self
from io import BytesIO

from pydantic import BaseModel, field_validator, model_validator, Field, PrivateAttr


class ColoredFormatter(logging.Formatter):
    """
    Custom logging formatter that logs output colorful
    """

    # Define agent-specific colors
    AGENT_COLORS = {
        # Tool-llm
        "Tool Generator": "\x1b[31;20m",  # Dim Red
        "Tool Evaluator": "\x1b[33;20m",  # Dim Yellow
        "Output Generator": "\x1b[32;20m", # Dim Green

        # Simple Roles
        "system": "\x1b[93m",  # Light Yellow
        "assistant": "\x1b[94m",  # Light Blue
        "user": "\x1b[97m",  # Light White

        # Default
        "Default": "\x1b[38;20m",  # Dim White
    }

    def format(self, record):
        agent_name = getattr(record, "agent_name", "Default")
        color = self.AGENT_COLORS.get(agent_name, self.AGENT_COLORS["Default"])

        # Get timestamp and formatted base string
        timestamp = self.formatTime(record, "%Y-%m-%d %H:%M:%S")
        base = f"{timestamp} [{record.levelname}] {agent_name} -"

        # Split messages into lines to make colorful logging work in docker
        message_lines = record.getMessage().splitlines()
        formatted_lines = [
            f"{color}{base} {message_lines[0]}\x1b[0m",
        ] + [
            f"{color}{' ' * len(base)} {line}\x1b[0m"
            for line in message_lines[1:]
        ]

        return "\n".join(formatted_lines)


# Define a logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Reduce logging level for httpx
logging.getLogger("httpx").setLevel(logging.WARNING)

# Create colorful logging handler for agent messages
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(ColoredFormatter())

# Attach handler to root logger
logger.addHandler(console_handler)


class ConnectInfo(BaseModel):
    url: str
    user: str | None
    pwd: str | None


class Message(BaseModel):
    user_query: str
    store_in_history: bool = True


class AgentMessage(BaseModel):
    """
    Stores individual information generated by the various agents

    Attributes:
        agent (str): The name of the agent
        content (str): The content of the message
        tools (List[Dict[str, Any]]: List of generated tool calls
        response_metadata (Dict[str, Any]): Metadata associated with the response including token usage
        execution_time (float): Time it took to execute the response
        status:
    """
    agent: str
    content: str = ''
    tools: List[Dict[str, Any]] = []
    response_metadata: Dict[str, Any] = {}
    execution_time: float = .0
    formatted_output: Any = None
    status: str = Field(default="", description="Status of the agent's execution (e.g., 'Planning', 'Executing', 'Completed')")
    step: str = Field(default="", description="Current step being executed")


class Response(BaseModel):
    """
    Stores relevant information that have been generated by the backends
    """
    query: str = ''
    agent_messages: List[AgentMessage] = []
    iterations: int = 0
    execution_time: float = .0
    content: str = ''
    error: str = ''

class OpacaFile(BaseModel):
    """
    Represents a single uploaded PDF file.
    """
    _content: BytesIO = PrivateAttr() # Private attribute to store binary content (not part of schema or validation)
    content_type: str  # MIME type of the file
    file_id: Optional[str] = None  # ID assigned after upload


class SessionData(BaseModel):
    """
    Stores relevant information regarding the session, including messages, configuration,
    client instances, API keys, and uploaded files.

    Attributes:
        messages: List of conversation messages.
        config: Configuration dictionary.
        opaca_client: Client instance for Opaca (or similar).
        llm_clients: Dictionary of LLM client instances.
        uploaded_files: Dictionary storing each uploaded PDF file.
        valid_until: Timestamp until session is active. 
    """
    messages: List[Any] = []
    config: Dict[str, Any] = {}
    opaca_client: Any = None
    llm_clients: Dict[str, Any] = {}
    abort_sent: bool = False
    uploaded_files: Dict[str, OpacaFile] = {}
    valid_until: float = -1


class ConfigArrayItem(BaseModel):
    type: str
    array_items: 'Optional[ConfigArrayItem]' = None


class ChatMessage(BaseModel):
    """Model for storing chat history messages"""
    role: str
    content: str | List[Dict[str, Any]]


class ConfigParameter(BaseModel):
    """
    A custom parameter definition for the configuration of each implemented method
    Valid types are ["integer", "number", "string", "boolean", "array", "object", "null"]
    """
    type: str
    required: bool
    default: Any
    array_items: Optional[ConfigArrayItem] = None
    description: Optional[str] = None
    minimum: Optional[int | float] = None
    maximum: Optional[int | float] = None
    enum: Optional[List[Any]] = None

    @model_validator(mode='after')
    def validate_after(self: Self) -> Self:
        if self.type == 'array' and self.array_items is None:
            raise ValueError(f'ConfigParameter.array_items cannot be "None" if ConfigParameter.type is "array"')
        if self.minimum is not None and self.maximum is not None and self.maximum < self.minimum:
            raise ValueError(f'ConfigParameter.maximum has to be larger than ConfigParameter.minimum')
        if self.enum is not None and self.default not in self.enum:
            raise ValueError(f'ConfigParameter.default must be one of {self.enum}')
        if (self.minimum is not None or self.maximum is not None) and self.type not in ["integer", "number"]:
            raise ValueError(f'The fields minimum and maximum can only be set for the types "integer" or "number".')
        return self

    # noinspection PyNestedDecorators
    @field_validator('type', mode='after')
    @classmethod
    def type_validator(cls, value: str) -> str:
        if value not in ["integer", "number", "string", "boolean", "array", "object", "null"]:
            raise ValueError(f'Value type "{value}" is not valid')
        return value


class ConfigPayload(BaseModel):
    value: Any
    config_schema: Dict[str, ConfigParameter]          # just 'schema' would shadow parent attribute in BaseModel


class OpacaException(Exception):

    def __init__(self, user_message: str, error_message: str | None = None, status_code: int = 400):
        super().__init__(user_message)
        self.user_message = user_message
        self.error_message = error_message
        self.status_code = status_code
